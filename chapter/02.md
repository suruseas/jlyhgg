---
title: "Starting Out - さぁ、はじめよう"
layout: chapter
---

## <a name="2.1">Ready, set, go! - 位置について、よーい、ドン!</a>

<img src="//s3.amazonaws.com/lyah/startingout.png" alt="挿絵 egg" class="img-right">

よろしい、
では、はじめよう!
あなたがIntroductionの内容を読まずにスキップするような、ひどい人間だとしたら、
Introductionの最後の節を読むハメになるだろう。
なぜなら、このチュートリアルをこなすのに必要なことと関数の読み込み方が説明されているからだ。
我々が最初にやることは、GHCを対話モードで実行することだ。
それから、いくつかの関数を呼び出して、基本的なHaskellの雰囲気をつかむ。
では、ターミナルを開いてghciと入力しよう。
こんな感じで、あなたを迎えてくれるはずだ。

    $ ghci
    GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
    Prelude>

おめでとう、あなたはghciの中にいる!
ところで、プロンプトが`Prelude> `となっている。
セッションになにかを読み込むと、このプロンプトは長くなるから、
`ghci> `を使うことにする。
同じプロンプトにしたければ、`:set prompt "ghci> "`と入力する。

    Prelude> :set prompt "ghci> "
    ghci>

以下は、単純な算数だ。

    ghci> 2 + 15
    17
    ghci> 49 * 100
    4900
    ghci> 1892 - 1472
    420
    ghci> 5 / 2
    2.5

これらは、かなり自明なことだ。
いくつかの演算子を1行で使うこともできるし、
演算子は通常の優先順位の規則に従う。
それから、かっこを使って、優先度を明示的にしたり、変更したりできる。

    ghci> (50 * 100) - 4999
    1
    ghci> 50 * 100 - 4999
    1
    ghci> 50 * (100 - 4999)
    -244950

マジすごくね?
ああ、もちろんそうじゃないことは分かっている。冗談だ。
ここで、少し注意しないといけないハマりどころがある。負の数だ。
負の数があるのなら、常にそれをかっこで包んだほうが良い。
`5 * - 3`すると、ghciに怒られるが、
`5 * (-3)`は、問題なく機能する。

ブール代数もかなり直感的だ。
御存知かもしれないが、`&&`は論理積を意味し、`||`は論理和を意味する。
そして、`not`は`True`と`False`を反転させる。

    ghci> True && False
    False
    ghci> True && True
    True
    ghci> False || True
    True
    ghci> not False
    True
    ghci> not (True && True)
    False

等しさの判定は、以下のように行う。

    ghci> 5 == 5
    True
    ghci> 1 == 0
    False
    ghci> 5 /= 5
    False
    ghci> 5 /= 4
    True
    ghci> "hello" == "hello"
    True

では、`5 + "llama"`や、`5 == True`をすると、どうなるだろう?
そうだね、最初のコードを試そうとすると、オドロオドロしいエラーメッセージが得られる。

    ghci> 5 + "llama"
    <interactive>:3:3:
        No instance for (Num [Char]) arising from a use of ‘+’
        In the expression: 5 + "llama"
        In an equation for ‘it’: it = 5 + "llama"

あらら!
ここで、ghciが我々に伝えているのは、`"llama"`は数値ではないから、どのように`5`と足すのかわからない、ということだ。
たとえ、`"llama"`が`"four"`や`"4"`だったとしても、Haskellはそれが数値であるとは認めない。
`+`は、その左右にあるものが数値であることを期待する。
もし、`True == 5`とすると、GHCIはそれらの型が一致しないと我々に伝える。
`+`は、数値とみなせるものに対して機能する一方で、`==`は比較ができるものに対して機能する。
しかし、ここで重要なのは、どちらも同じ型である必要がある、ということだ。
りんごとみかんは比較できない。
型については、後で詳しく見ていく。
メモ:
`5 + 4.0`というのは可能だ。なぜなら、`5`は整数としても浮動小数点数としても振る舞える。
`4.0`は整数のように振る舞えないから、`5` には浮動小数点数が適用されなくてはならない。

さて、あなたはまだ気づいていないかもしれないが、我々はもうずっと関数を使ってきたのだ。
たとえば、`*`というのは2つの数値を受け取り、それらを掛け合わせる関数だ。
あなたが見たとおり、それを数値で挟むことにより呼び出される。
これは、我々が中置関数(infix function)と呼んでいるものだ。
数値を扱わないほとんどの関数は、前置関数(prefix function)だ。
では、見てみよう。

<img src="//s3.amazonaws.com/lyah/ringring.png" alt="挿絵 phoen" class="img-right">

通常、関数は前置関数となる為これ以降は関数が前置関数であるとは明示せず、そうであると仮定する。
多くの命令的言語における関数は、
関数の名前を書いてから、通常はカンマで区切られたパラメータをかっこの中に書くことで呼び出される。
Haskellでは、
関数は関数の名前、1つのスペース、そしてスペースで区切られたパラメータを書くことで呼び出される。
手始めに、
Haskellの中で最もつまらない関数を呼び出してみよう。

    ghci> succ 8
    9

`succ`関数は、サクセッサが定義されたものであれば何でも受け取り、サクセッサ(後に続くもの)を返す。
ご覧のとおり、関数の名前とパラメータをスペースで区切っている。
パラメータが複数ある関数を呼び出すのも単純だ。
`min`関数と`max`関数は、数値のような順番に並べることのできるものを2つ受け取る。
`min`は小さい方を、`max`は大きい方を返す。
自分自身の目で確認してみよう。

    ghci> min 9 10
    9
    ghci> min 3.4 3.2
    3.2
    ghci> max 100 101
    101

関数適用
(スペースを置いてから、パラメータを入力することで関数を呼び出すこと)は、
優先度の中でも最高の優先度をもつ。
それが我々にとって何を意味するかというと、これら2つの文は等しいということだ。

    ghci> succ 9 + max 5 4 + 1
    16
    ghci> (succ 9) + (max 5 4) + 1
    16

しかし、たとえば9と10を乗算した結果のサクセッサを得ようとして、
`succ 9 * 10`と書くことはできない。
なぜなら`9`のサクセッサが得られてから、
それが`10`と乗算される。
つまり、`100`になる。
`91`を得るには、`succ (9 * 10)`と書かなくてはならない。

関数が2つのパラメータを受け取る場合、
それをバックチック`` ` ``で囲むことにより、中置換数として呼び出すことができる。
たとえば、`div`関数は、2つの整数を受け取り、それらを整数として除算する。
`div 92 10`すると、`9`となる。
しかし、そのように関数を呼び出すと、
どちらが割る数で、どちらが割られる数なのかという混乱が生じるおそれがある。
そこで、``92 `div` 10``とすると中置換数として呼び出すことができ、より明確になる。

命令的言語からやってきた多くの人達は、
かっこが関数適用を示すものであるという観念に陥りがちだ。
たとえばC言語では、関数を呼び出すのに、`foo()`や`bar(1)`、`baz(3, "haha")`などのようなかっこの使い方をする。
先程述べたように、Haskellでは関数適用にスペースが使われる。
つまり、これらの関数はHaskellにおいて、`foo`、`bar 1`、`baz 3 "haha"`のようになる。
もし、`bar (bar 3),`を見ても、
`bar`と`3`というパラメータで`bar`が呼び出されているという意味ではない。
これは、最初に関数`bar`を`3`というパラメータで呼び出して何らかの数値を得てから、
再び関数`bar`をその数値で呼び出す、ということを意味する。
C言語では、`bar(bar(3))`のようになるだろう。



## <a name="2.2">Baby's first functions - よちよち関数</a>

前の節では、関数呼び出しの基本的な雰囲気を掴んだ。
では、自分で自分の関数を作ってみよう!
お好みのテキストエディタを開き、
、数値を1つ受け取り、それに2をかけるという関数を打ち込もう。

    doubleMe x = x + x

関数は、それが呼び出される時と似たような方法で定義される。
関数名には、スペースで区切られたパラメータが続く。
しかし、関数定義のときは`=`が存在し、その後に関数が何をするかを定義する。
では、これを`baby.hs`などの名前で保存する。
それから、保存した場所へ移動して、ghciを実行する。
ghciの中に入ったら、`:l baby`とする。
さて、スクリプトは読み込まれ、
我々が定義した関数で遊べるようになった。

    ghci> :l baby
    [1 of 1] Compiling Main             ( baby.hs, interpreted )
    Ok, modules loaded: Main.
    ghci> doubleMe 9
    18
    ghci> doubleMe 8.3
    16.6

`+`は整数だけでなく浮動小数点数にも、機能するので、
(実際には、数値と考えられるものに対しては)
どんな数値に対しても我々の関数は機能する。
では、2つの数値を受け取り、それらに2をかけてから、それらを足し合わせるという関数を定義してみよう。

    doubleUs x y = x*2 + y*2

単純だ。
これは、`doubleUs x y = x + x + y + y`と定義することもできる。
テストしてみれば、予想通りの結果が得られる。
(この関数を`baby.hs`に追加してから保存して、
、ghciの中で`:l baby.hs`するのをお忘れなく。)

    ghci> doubleUs 4 9
    26
    ghci> doubleUs 2.3 34.2
    73.0
    ghci> doubleUs 28 88 + doubleMe 123
    478

ご想像の通り、
あなたが作った関数を他の関数から呼び出すことができる。
これを踏まえて、`doubleUs`は以下のように再定義できる。

    doubleUs x y = doubleMe x + doubleMe y

これはHaskellで目にする共通のパターンの簡単な一例だ。
明らかに正しい基本的な関数を作ってから、それをより複雑な関数へと組み合わせる。
あなたは、この方法により繰り返しを避ける。
では、ある数学者が`2`は実際には`3`であることを発見してプログラムを書き換え無くてはならないとしたら?
あなたは`doubleMe`を`x + x + x`と再定義できる。
`doubleUs`は`doubleMe`を呼び出しているから、
`2`が`3`であるという奇妙な新しい世界でも自動的に機能する。

Haskellにおける関数は、特に順序は必要ないので、
最初に`doubleMe`を定義してから`doubleUs`を定義するか、別の方法で定義するかは問題にならない。

では、数値を受け取り、それに2をかける関数を作ることに仕様。
ただし、その数値が`100`より小さいか等しい場合に限る。
`100`より大きい数値は十分に大きいからね!

    doubleSmallNumber x = if x > 100
                            then x
                            else x*2

<img src="//s3.amazonaws.com/lyah/baby.png" alt="挿絵 this is you" class="img-left">

ここで、Haskellにおけるif文を紹介しよう。
あなたは他の言語のif文に馴染みがあるかもしれない。
Haskellのif文と命令的言語のif文との違いは、Haskellではelseの部分が必須であるところだ。
命令的言語では、条件を満たさない場合のステップを飛び越えることができるが、
Haskellではすべての式、関数がなにかを必ず返さなくてはならない
if文を1行に書くこともできるが、
私はこの書き方のほうが読みやすいと思う。
それからもう一つ、Haskellのif文は式だ。
式というのは基本的に、何らかの値を返すひとかけらのコードである。
`5`は`5`という値を返すから、式である。
`4 + 8`は式であり、
`x + y`も`x`と`y`の合計を返すから、式である。
`else`は必須であるから、
if文は常になにかを返すことになり、これが指揮である理由となる。
先程の関数が生成する数値すべてに`1`を足したい場合、
そのボディはこのように書ける。

    doubleSmallNumber' x = (if x > 100 then x else x*2) + 1

かっこを忘れると、
`x`が`100`より大きくない場合に`1`がたされる。
関数名の最後にある`'`に注目してほしい。
Haskellのシンタックスにおいて、このアポストロフィーは特別な意味を持たない。
関数名として使える有効な文字だ。
通常、`'`はある関数の厳密なヴァージョン(lazyではない)を示すか、
関数を僅かに変更したヴァージョンであることを示すか、あるいは変数名に使う。
`'`は関数名として有効な文字であるから、このような関数が作れる。

    conanO'Brien = "It's a-me, Conan O'Brien!"

ここで注目すべきことが2つある。
1つ目は、関数の名前、Conanの名前を大文字から始めていないということ。
これは、関数名を大文字から始められないためだ。
理由については、少し後で見よう。
2つ目は、この関数がパラメータを一切受け取らないというところだ。
関数がパラメータを一切受け取らない時、
それは通常、定義(または名前)と呼ぶ。
一度定義した名前(と関数)の意味は変更できないため、
`conanO'Brien`と文字列`"It's a-me, Conan O'Brien!"`は、交換可能なものとして使うことができる。



## <a name="2.3">An intro to lists - リストのご紹介</a>

<img src="//s3.amazonaws.com/lyah/list.png" alt="挿絵 BUY A DOG" class="img-left">

さて、次はリストについて説明しよう。Haskellにおけるリストはhomogenousなデータ構造だからたとえば `[123, True, "foo"]`というリストは作れない。次のように、リストの中身は同じ種類に揃える必要がある。(`let`は値の定義に使う。後で詳しく説明)リストは`[]`で値を包む。値は`,`で区切る。`,`と値の間にスペースが挟まれてもOKだ。

    ghci> let lostNumbers = [4,8,15,16,23,42]
    ghci> lostNumbers
    [4,8,15,16,23,42]

文字列はCharのリストになっている。例えば`"hello"`は`['h', 'e', 'l', 'l', 'o']`のシンタックスシュガーになる。

    ghci> "hello" == ['h', 'e', 'l', 'l', 'o']
    True

リストを連結するには`++`を使う。

    ghci> [1,2,3,4] ++ [9,10,11,12]
    [1,2,3,4,9,10,11,12]

もちろん、1つの値しか持たないリストを連結することもできる。

    ghci> [1,2,3] ++ [4]
    [1,2,3,4]

リストの先頭に値を追加したい場合、`:` (cons operatorとも言う)を使う。

    ghci> 'A':" SMALL CAT"
    "A SMALL CAT"
    ghci> 5:[1,2,3,4,5]
    [5,1,2,3,4,5]

実は`[1,2,3]`というのもシンタックスシュガーで、実際には`1:2:3:[]`と等しい。([]は空のリスト)

    ghci> 1:2:3:[]
    [1,2,3]

リストからインデックスを指定して値を取り出すには、`!!`を使う。

    ghci> "Steve Buscemi" !! 6
    'B'
    ghci> [9.4,33.2,96.2,11.2,23.25] !! 1
    33.2

存在しないインデックスを与えるとエラーになる。

    ghci> [1,2,3] !! 4
    *** Exception: Prelude.!!: index too large

リストは、リストのリスト、のリスト...のように、ネストすることができる。

    ghci> [[1,2], [3]]
    [[1,2],[3]]

ただし、最初に説明したように、リストの中身は同じ種類にする必要があるから注意してほしい。例えば`[1, [2,3]]`が含んでいるのははIntegerとリストのリストだから、エラーになる。

    ghci> [1,[2,3]]
    <interactive>:33:1:
        Non type-variable argument in the constraint: Num [t]
        (Use FlexibleContexts to permit this)
        When checking that ‘it’ has the inferred type
          it :: forall t. (Num t, Num [t]) => [[t]]

ここで便利な機能を紹介しよう。`>`や`==`などを使って、リストとリストを比較することができる。左側のリストの0番目の値と、右側のリストの0番目の値を比較して、次に左側のリストの1番目の値と右側のリストの1番目の値を比較して...というのを繰り返し、リスト内のすべての要素が条件を満たせば、`True`となる。

    ghci> [3,2,1] > [2,1,0]
    True

他にもリストを操作できる便利な関数が用意されている。headはリストの先頭から要素を1つ取り出す。

    ghci> head [1,2,3]
    1

tailはリストから先頭の要素を取り除いたリストを返す。

    ghci> tail [1,2,3]
    [2,3]

lastはリストの末尾の要素を取り出す。

    ghci> last [1,2,3]
    3

initはリストから末尾の要素を取り除いたリストを返す。

    ghci> init [1,2,3]
    [1,2]

ちなみに、これらは`[]`に対して使うとエラーになる。エラーは実行時に初めてわかるので、`[]`は慎重に扱う必要がある。

    ghci> head []
    *** Exception: Prelude.head: empty list
    ghci> tail []
    *** Exception: Prelude.tail: empty list
    ghci> last []
    *** Exception: Prelude.last: empty list
    ghci> init []
    *** Exception: Prelude.init: empty list

lengthはリストの長さを返す。

    ghci> length [1,2,3]
    3
    ghci> length []
    0

nullはリストが`[]`か判定する。

    ghci> null [1,2,3]
    False
    ghci> null []
    True

reverseはリストを反転する。

    ghci> reverse [1,2,3]
    [3,2,1]
    ghci> reverse []
    []

takeはリストの先頭から指定した数だけ、リストとして値を取り出す。指定した数がリストの長さより大きければ、リストをそのまま返す。

    ghci> take 2 [1,2,3]
    [1,2]
    ghci> take 4 [1,2,3]
    [1,2,3]

dropはtakeと逆の働きをする。

    ghci> drop 2 [1,2,3,4,5]
    [3,4,5]
    ghci> drop 10 [1,2,3,4,5]
    []

maximumはリストの中から最大値を取り出す。

    ghci> maximum [1,2,3]
    3

sumはリストの総和を返す。

    ghci> sum [1,2,3]
    6

productはリストの層積を返す。

  ghci> product [1,2,3,4]
  24

elemはリスト内に与えられた要素が含まれているか判定する。

    ghci> elem 1 [1,2,3]
    True
    ghci> elem 4 [1,2,3]
    False

elemはinfix functionとして使うほうが読みやすい。

    ghci> 1 `elem` [1,2,3]
    True
    ghci> 4 `elem` [1,2,3]
    False



## <a name="2.4">Texas ranges - テキサス・レンジャー巣</a>

1,2,3...やa,b,c...など、列挙できる￥値のリストを作るときにはrangeを使うことができる。

    ghci> [1,2,3,4,5] == [1..5]
    True

rangeはその感覚を設定できるので、たとえば奇数のリストを作成できる。

    ghci> [1,3 .. 20]
    [1,3,5,7,9,11,13,15,17,19]

rangeは単に先頭2つの値の差を次の値に足しているだけなので、たとえば`[1,4,9,16]`というリストは作れない。

    ghci> [1,4.20]
    [1.0,4.2]

また、`[10..1]`というのは`[]`になるので`[10,9..1]`とする必要がある。

    ghci> [10..1]
    []
    ghci> [10,9..1]
    [10,9,8,7,6,5,4,3,2,1]

rangeでは実数が使えるものの、誤差が積み重なると値が正確ではなくなる。rangeでは実数を使うのはおすすめしない。

    ghci> [0.1, 0.3 .. 1]
    [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  [

さて、ここで興味深い機能を紹介しよう。Haskellでは無限のリストを作り、値を取り出すことができる。ちなみに、`[1..]`とだけ入力すると、`[1,2,3...`と無限に結果が表示され続けてしまう。そのときは、`Ctrl-C`でキャンセルしよう。

    ghci> take 5 [1..]
    [1,2,3,4,5]

cycleは与えたリストを繰り返し、無限リストを作る。

    ghci> take 10 (cycle [1,2,3])
    [1,2,3,1,2,3,1,2,3,1]

repeatは与えた値で無限リストを作る。

    ghci> take 10 (repeat 7)
    [7,7,7,7,7,7,7,7,7,7]

replicateは第2引数で与えた値を第1引数の数だけ繰り返し、リストを作る。

    ghci> replicate 3 10
    [10,10,10]



## <a name="2.5">I'm a list comprehension - 我はリスト内包表記</a>

ここで、ちょっとした数学の話をしよう。大丈夫、難しい話はしないから読み続けてほしい。以下の数式は、2,4,6...という偶数を10個含む集合を表している。ちなみに、$2 \cdot x$はoutput function、$x$はvariable。$\mathbb{N}$はinput set、$x \leq 10$はpredicateという。

```math
\{2 \cdot x \mid x \in \mathbb{N}, x \leq 10 \}
```

この数式をHaskellで書いてみよう。

    take 10 [2,4..10]

うん、まぁ便利だけど、でも、もっと複雑な場合は?



### List comprehension

もう一度、2,4..という偶数を10個とりだしてみる。List comprehensionを使うと、以下のように書ける。`x`には`[1..10]`から取り出された値が入る。そして、2倍されたxのリストが得られる。

    ghci> [2*x | x <- [1..10]]
    [2,4,6,8,10,12,14,16,18,20]

いいね、期待通り！

次は、条件(predicate)を加えてみる。条件は、`,`で区切った後に書く。試しに、「2倍された値が12より大きいか等しい」という条件を加えてみる。

    ghci> [2*x | x <- [1..10], 2*x >= 12]
    [12,14,16,18,20]

おお、期待通り！じゃあ、「50から100までの自然数の内、7で割ったあまりが3になる数」を求めるには?

    ghci> [x | x <- [50..100], x `mod` 7 == 3]
    [52,59,66,73,80,87,94]

これは便利。ちなみに、リストからpredicateにもとづいて取り出す値を決めることをfilterとも言う。

次は、「10より大きいか等しい奇数は"BANG!"、10より小さい奇数は"BOOM!"、それ以外の数は、何も表示しない(リストに含めない)。」というリストを作ってみる。もちろん、functionのなかでlist comprehensionを使うこともできる。

    boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]

predicateに注目。`odd x`は、`x`が奇数の場合`True~を、そうでない場合は`False`を返す。前に確認したとおり、predicateがTrueになると、リストに値が含まれ、Falseのときはリストから値が覗かれる。

    ghci> boomBangs [7..13]
    ["BOOM!","BOOM!","BANG!","BANG!"]

もちろん、複数のpredicateを使うこともできる。例として、「10から20までの数の内、13、15、19を含めないリスト」を作ってみる。

    ghci> [x | x <- [10..20], x /= 13, x /= 15, x /= 19]
    [10,11,12,14,16,17,18,20]

リストに含まれるのは、すべてのpredicateを満たした値のみ、なので注意してほしい。

次は、複数のリストから値を取り出してみよう。取り出した値は、output functionでjoinできる。例として、リスト`[1,2,3]`と`[4,5,6]`の直積を求めてみよう。

    ghci> [x*y | x <- [1,2,3], y <- [4,5,6]]
    [4,5,6,8,10,12,12,15,18]

`x*y`の組み合わせは、1と4、2と5、3と6ではなく、1と4、1と5、1と6、2と4...となるので注意。この場合、結果として、リストの長さは3 * 3 = 9になる。

次は、`x*y >= 50`というpredictを与えてみる。

    ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
    [55,80,100,110]

文字列はリストだから、この機能は文字列に対しても使える。

    ghci> let nouns = ["hobo","frog","pope"]
    ghci> let adjectives = ["lazy","grouchy","scheming"]
    ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
    ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
    "grouchy pope","scheming hobo","scheming frog","scheming pope"]

さて、ここで`length`を自分で作ってみよう。

    length' xs = sum [1 | _ <- xs]

上記の`_`という変数は、この変数は意味を持たない、という意味を表す。つまり、実際には使わない、ダミーの変数であることを示すのに使う。この機能を使うと、たとえば変数を受け取るものの、その変数は使わない、という関数を定義することができる。

    ghci> let mom _ = "Do your homework!"
    ghci> mom "I want to play video games!"
    "Do your homework!"
    ghci> mom "OK. How about playing video games for 10 minutes?"
    "Do your homework!"

おっと、話を元に戻そう。`length'`は、与えられたリスト`xs`に含まれる値を、すべて`1`で置き換える。その後`sum`でリストの値の合計を求める。結果として、与えたリストの長さが得られる、というわけだ。

では、与えられた文字列から小文字を取り除く、という関数を作ってみよう。

    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

文字列もリストだから、この関数は期待通り機能するはずだ。

    ghci> removeNonUppercase "Hahaha! Ahahaha!"
    "HA"
    ghci> removeNonUppercase "IdontLIKEFROGS"
    "ILIKEFROGS"

期待通り！もちろん、predicateの中で、リストが使える。そして、リストを含むリスト、も使えることに注目してほしい。ということで、リストの形を保ったまま、奇数を取り除く関数を作ってみよう。

    ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
    ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
    [[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]

リストを含むリスト、は読みづらいから開業するのがおすすめだ。



## <a name="2.6">Tuples - タプル</a>

一つ、あるいは複数の値を保持できるという点で、タプルとリストは似ている。ただし、リストは無限リストが作れるのに対し、タプルではそれができない。そして、もう一つの重要な違いは、タプルはhomogenousではない、というところだ。タプルでは、異なる方の値を保持できる。タプルは`()`で値を包んで表す。値は`,`で区切る。

ここで、二次元のベクトルをHaskellで表現する方法を考えてみよう。ひとつはリストを使う方法...[x,y]とすれば、多分、期待通りに動くと思う。じゃあ、二次元の平面上で、なにか図形を表現するとして、幾つかのベクトルを含むリストを作ったらどうなる?そうだね、`[[1,2],[8,11],[4,5]]`という書き方ができる。

    ghci> [[1,2], [3,4], [5,6]]
    [[1,2],[3,4],[5,6]]

ただし，これには問題がある。Haskellのリストは、同じ種類の値しか含めることができない。逆に言えば、例えば`[[1,2], [3,4,5], [6,7]]`というリストはエラーにはならない。「リストを含むリスト」という構造には違反していないからだ。これでは、`[3,4,5]`という3次元のベクトルが含まれるのを防げない。

    ghci> [[1,2], [3,4,5], [6,7]]
    [[1,2],[3,4,5],[6,7]]

ここで、タプルの出番だ。タプル(要素数が2つの場合はペアとも言う)は、それ自身がtypeとして振る舞う。つまり、`(1,2)`と`(1,2,3,)`は違うものとして扱われる。試してみよう。

    ghci> [(1,2), (3,4), (5,6)]
    [(1,2),(3,4),(5,6)]

おおっと、間違えて3次元のベクトル`(3,4,5)`を含めてしまった！

    ghci> [(1,2), (3,4,5), (6,7)]
    <interactive>:97:9:
        Couldn't match expected type ‘(t, t1)’
                    with actual type ‘(Integer, Integer, Integer)’
        Relevant bindings include
          it :: [(t, t1)] (bound at <interactive>:97:1)
        In the expression: (3, 4, 5)
        In the expression: [(1, 2), (3, 4, 5), (6, 7)]
        In an equation for ‘it’: it = [(1, 2), (3, 4, 5), (6, 7)]

このエラーは、「リストには要素数が2つのタプルしか含まれないはずなのに、要素数が3つのタプルが含まれている。」ということを報告している。

もちろん、タプルの要素数だけではなく、タプルに含まれるtypeの組み合わせが一致しなければならない。ということで、、`[(1,2), ("foo", "bar)]`というリストも作ることができない。

    ghci> [(1,2), ("foo", "bar")]
    <interactive>:101:3:
        No instance for (Num [Char]) arising from the literal ‘1’
        In the expression: 1
        In the expression: (1, 2)
        In the expression: [(1, 2), ("foo", "bar")]

タプルは異なるtypeの値を含めることができる。例えば、性、名、年齢をまとめたデータ構造を作ることができる。

    ghci> ("Christopher", "Walken", 55)
    ("Christopher","Walken",55)

タプルの注意点は、すべてのタプルで共通に使える関数は作れない、というところだ。そして、要素数が1つのタプルは、値そのものになる、というところだ。というより、値と、要素数が1のタプルを区別できない、というのが正しい。

    ghci> (1) == 1
    True
    ghci> ("foo") == "foo"
    True

タプルはリストのように比較できる。ただし、先程説明したとおり、すべてのタプルに対して使用できる関数は作ることができない。最初から定義されているのは、ペアに対する関数だけだ。要素数が2より大きいタプルから値を取り出す方法は後で説明する。

`fst`はペアの1つ目の値を取り出す。

    ghci> fst (8,11)
    8
    ghci> fst ("Wow", False)
    "Wow"

`snd`はペアの2つ目の値を取り出す。

    ghci> snd (8,11)
    11
    ghci> snd ("Wow", False)
    False

`zip`は、リスト1とリスト2を与えると、リスト1のn番目の要素とリスト2のn番目の要素を含むペアを作る。

    ghci> zip [1,2,3,4,5] [5,5,5,5,5]
    [(1,5),(2,5),(3,5),(4,5),(5,5)]
    ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]
    [(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]

`zip`は、リストの要素数が一致しない場合、要素数は小さい方に合わせる。

    ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
    [(5,"im"),(3,"a"),(2,"turtle")]

`zip`は、無限リストに対しても使える。

    ghci> zip [1..] ["apple", "orange", "cherry", "mango"]
    [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]

では、タプルとlist comprehensionを組み合わせた問題を説いてみよう。すべての辺が10より小さいか等しく、3辺の合計が24となる直角三角形を求めよう。まずは、すべての辺が10より小さいか等しい三角形を求める。

    ghci> let triangles = [(a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10]]

`triangles`は、辺の長さが10より小さい三角形を列挙した結果となる。

    ghci> triangles
    [(1,1,1),(2,1,1),(3,1,1),(4,1,1),(5,1,1),(6,1,1...

次は、直角三角形という条件を加えよう。直角三角形は$a&2 + b^2 = c^2$となる。cが3つの辺の内、最も長い変だから、aとbはそれより小さくなる。これをHaskellで書くと、こうなる。

    ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
    ghci> rightTriangles
    [(3,4,5),(6,8,10)]

あとは、3辺の合計が24、という条件を加えれば完成だ。

    ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
    ghci> rightTriangles'
    [(6,8,10)]

まずは、問題から導かれる答えの断片を集めて、それから答えの断片を組み合わせたり、変形させたり、フィルターしたりして、目的の答えを得る。これがfunctional programmingの定石だ。
